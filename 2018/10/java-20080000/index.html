<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java内存模型," />










<meta name="description" content="1. 硬件的效率与一致性多任务处理在现代计算机操作系统中几乎已经是一项必备的功能了，一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层">
<meta name="keywords" content="java内存模型">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发--内存模型">
<meta property="og:url" content="https://lizy-tech.github.io/2018/10/java-20080000/index.html">
<meta property="og:site_name" content="lizy-tech">
<meta property="og:description" content="1. 硬件的效率与一致性多任务处理在现代计算机操作系统中几乎已经是一项必备的功能了，一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lizy-tech.github.io/2018/10/java-20080000/处理器-高速缓存-主内存.png">
<meta property="og:image" content="https://lizy-tech.github.io/2018/10/java-20080000/java-memory.png">
<meta property="og:image" content="https://lizy-tech.github.io/2018/10/java-20080000/线程-工作内存-主内存.png">
<meta property="og:image" content="https://lizy-tech.github.io/2018/10/java-20080000/指令重排.png">
<meta property="og:updated_time" content="2018-10-23T08:51:51.026Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发--内存模型">
<meta name="twitter:description" content="1. 硬件的效率与一致性多任务处理在现代计算机操作系统中几乎已经是一项必备的功能了，一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层">
<meta name="twitter:image" content="https://lizy-tech.github.io/2018/10/java-20080000/处理器-高速缓存-主内存.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lizy-tech.github.io/2018/10/java-20080000/"/>





  <title>java并发--内存模型 | lizy-tech</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lizy-tech</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">编程的苦与乐</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lizy-tech.github.io/2018/10/java-20080000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizhiyong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lizy-tech">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发--内存模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-11T16:06:20+08:00">
                2018-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,205 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h1><p>多任务处理在现代计算机操作系统中几乎已经是一项必备的功能了，一般衡量一个服务器性能的高低好坏，使用每秒事务处理数（Transactions Per Second，TPS）这个指标比较能说明问题，它代表着一秒内服务器平均能响应的请求数，而TPS值与程序的并发能力有着非常密切的关系。由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。这样很好地解决了处理器与内存的速度矛盾的同时，也引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存。<br><img src="/2018/10/java-20080000/处理器-高速缓存-主内存.png" title="图1 处理器-高速缓存-主内存间的交互关系"><br><strong>CPU,CPU高速缓存,内存协同工作过程</strong></p>
<ol>
<li>程序运行过程，会将所需要操作的业务数据加载到内存中，并复制一份到CPU的高速缓存中。</li>
<li>CPU指令执行时，直接从CPU高速缓存中读取和写入数据，提高工作效率。</li>
<li>CPU运算结束后，将结果写入CPU高速缓存，此时再同步至内存中。</li>
</ol>
<p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的，后续将介绍Java内存模型。<br>在介绍Java的内存模型之前我们首先来了解一下Java的内存区域。</p>
<h1 id="2-Java内存区域"><a href="#2-Java内存区域" class="headerlink" title="2. Java内存区域"></a>2. Java内存区域</h1><p>Java的内存区域如下：</p>
<img src="/2018/10/java-20080000/java-memory.png" title="图2 java内存区域">
<h2 id="2-1-程序计数器（Program-Counter-Register）"><a href="#2-1-程序计数器（Program-Counter-Register）" class="headerlink" title="2.1 程序计数器（Program Counter Register）"></a>2.1 程序计数器（Program Counter Register）</h2><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。属于<font color="FF0000"><strong>线程私有</strong></font></p>
<h2 id="2-2-虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#2-2-虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2.2 虚拟机栈（Java Virtual Machine Stacks）"></a>2.2 虚拟机栈（Java Virtual Machine Stacks）</h2><p>生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调直至执行完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程。虚拟机栈中局部变量表中存放了编译期可知的各种<font color="FF0000">基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）</font>。属于<font color="FF0000"><strong>线程私有</strong></font></p>
<h2 id="2-3-本地方法栈（Native-Method-Stacks）"><a href="#2-3-本地方法栈（Native-Method-Stacks）" class="headerlink" title="2.3 本地方法栈（Native Method Stacks）"></a>2.3 本地方法栈（Native Method Stacks）</h2><p>与虚拟机栈所发挥的作用相似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<h2 id="2-4-Java堆（Java-Heap）"><a href="#2-4-Java堆（Java-Heap）" class="headerlink" title="2.4 Java堆（Java Heap）"></a>2.4 Java堆（Java Heap）</h2><p>是Java虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆。由于现在收集器基本采用分代收集算法，所以Java堆中还可以细分为：<font color="FF0000">新生代和老年代</font>；再细致一点的有<font color="FF0000">Eden空间、From Survivor空间、To Survivor空间等</font>。属于<font color="FF0000"><strong>线程共享</strong></font></p>
<h2 id="2-5-方法区（Method-Area）"><a href="#2-5-方法区（Method-Area）" class="headerlink" title="2.5 方法区（Method Area）"></a>2.5 方法区（Method Area）</h2><p>主要用于存储已经被虚拟机加载的<font color="FF0000">类信息、常量、静态常量、即时编译器编译后的代码等数据</font>，又称Non-Heap（非堆）。属于<font color="FF0000"><strong>线程共享</strong></font></p>
<h1 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3. Java内存模型"></a>3. Java内存模型</h1><p>Java虚拟机规范中试图定义一种Java内存模型 (Java Memory Model , JMM) 来<font color="FF0000">屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果</font>。</p>
<h2 id="3-1-主内存和工作内存"><a href="#3-1-主内存和工作内存" class="headerlink" title="3.1 主内存和工作内存"></a>3.1 主内存和工作内存</h2><p>Java内存模型的主要目标是定义<font color="FF0000">程序中各个变量(实例字段、静态字段和构成数组对象的元素)的访问规则</font>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图：</p>
<img src="/2018/10/java-20080000/线程-工作内存-主内存.png" title="图3 线程-工作内存-主内存交互关系">
<p>JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开的(稍后会分析)。<br>从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获得更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。</p>
<h2 id="3-2-内存间交互操作"><a href="#3-2-内存间交互操作" class="headerlink" title="3.2 内存间交互操作"></a>3.2 内存间交互操作</h2><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。虚拟机保证以下每一种操作都是原子的，不可拆分的。</p>
<blockquote>
<p><strong>lock(锁定)</strong>：作用于<font color="FF0000">主内存</font>的变量，把一个变量标识为一条线程独占状态。<br><strong>unlock(解锁)</strong>：作用于<font color="FF0000">主内存</font>变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。<br><strong>read(读取)</strong>：作用于<font color="FF0000">主内存</font>变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。<br><strong>load(载入)</strong>：作用于<font color="FF0000">工作内存</font>的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。<br><strong>use(使用)</strong>：作用于<font color="FF0000">工作内存</font>的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。<br><strong>assign(赋值)</strong>：作用于<font color="FF0000">工作内存</font>的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。<br><strong>store(存储)</strong>：作用于<font color="FF0000">工作内存</font>的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。<br><strong>write(写入)</strong>：作用于<font color="FF0000">主内存</font>的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p>
</blockquote>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。<font color="FF0000">Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行</font>。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但是工作内存不接受，或者从工作内存发起回写了但是主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>
<h2 id="3-3-重排序和内存屏障"><a href="#3-3-重排序和内存屏障" class="headerlink" title="3.3 重排序和内存屏障"></a>3.3 重排序和内存屏障</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>
<ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：</p>
<img src="/2018/10/java-20080000/指令重排.png" title="图4 指令重排">
<p>Java编译器、运行时和处理器都会保证<strong>单线程</strong>下的as-if-serial语义：所有的动作都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。</p>
<p>重排序需要满足happen before原则：</p>
<blockquote>
<ol>
<li>程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作</li>
<li>管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序，下同）对同一个锁的lock操作</li>
<li>volatile变量规则：对一个volatile变量的写操作happen-before后面对该变量的读操作</li>
<li>线程启动规则：Thread对象的start（）方法happen—before此线程的每一个动作</li>
<li>线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行</li>
<li>线程中断规则：对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始</li>
<li>传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C</li>
</ol>
</blockquote>
<p>当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<p>内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p>Java内存模型中主要提供了LoadLoad、LoadStore、StoreLoad和StoreStore四种内存屏障。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">屏障类型</th>
<th style="text-align:center">指令示例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LoadLoad</td>
<td style="text-align:center">Load1; LoadLoad; Load2</td>
<td style="text-align:center">确保Load1数据的装载，在Load2及其所有后续指令的装载之前</td>
</tr>
<tr>
<td style="text-align:center">StoreStore</td>
<td style="text-align:center">Store1; StoreStore; Store2</td>
<td style="text-align:center">确保Store1数据对其他处理器可见（刷新到内存），在Store2及其所有后续存储指令之前</td>
</tr>
<tr>
<td style="text-align:center">LoadStore</td>
<td style="text-align:center">Load1; LoadStore; Store2</td>
<td style="text-align:center">确保Load1数据装载，在Store2及其所有后续的存储指令之前</td>
</tr>
<tr>
<td style="text-align:center">StoreLoad</td>
<td style="text-align:center">Store1; StoreLoad; Load2</td>
<td style="text-align:center">确保Store1数据对其他处理器可见（刷新到内存中），在Load2及其所有后续装载指令之前</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-4-内存可见性"><a href="#3-4-内存可见性" class="headerlink" title="3.4 内存可见性"></a>3.4 内存可见性</h2><p><strong>可见性</strong>：一个线程对共享变量值的修改，能够及时地被其他线程看到<br><strong>共享变量</strong>：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量<br>由于java的内存模型有两条规定：</p>
<blockquote>
<ol>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读取</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>
</ol>
</blockquote>
<p>在这种模型下会有一个现象，缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的。这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致。</p>
<p>要实现共享变量的可见性，就必须保证以下两点：</p>
<blockquote>
<ol>
<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>
<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中</li>
</ol>
</blockquote>
<h3 id="3-4-1-volatile实现的可见性"><a href="#3-4-1-volatile实现的可见性" class="headerlink" title="3.4.1 volatile实现的可见性"></a>3.4.1 volatile实现的可见性</h3><p>volatile关键字：<font color="FF0000">能保证可见性，不保证复合操作的原子性</font></p>
<p>volatile通过加入内存屏障和禁止重排序优化来实现内存的可见性<br>    在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障<br>    在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</p>
<p>参考：<br>深入理解Java虚拟机——JVM高级特性与最佳实践<br><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</a></p>
<p><a href="https://blog.csdn.net/u011663071/article/details/78964991" target="_blank" rel="noopener">https://blog.csdn.net/u011663071/article/details/78964991</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java内存模型/" rel="tag"># java内存模型</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/leet-3014000/" rel="next" title="LeetCode-44-Wildcard Matching">
                <i class="fa fa-chevron-left"></i> LeetCode-44-Wildcard Matching
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/leet-3015000/" rel="prev" title="LeetCode-45-Jump Game">
                LeetCode-45-Jump Game <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lizhiyong</p>
              <p class="site-description motion-element" itemprop="description">菜鸟的涅槃梦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-硬件的效率与一致性"><span class="nav-number">1.</span> <span class="nav-text">1. 硬件的效率与一致性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Java内存区域"><span class="nav-number">2.</span> <span class="nav-text">2. Java内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-程序计数器（Program-Counter-Register）"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 程序计数器（Program Counter Register）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-虚拟机栈（Java-Virtual-Machine-Stacks）"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 虚拟机栈（Java Virtual Machine Stacks）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-本地方法栈（Native-Method-Stacks）"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 本地方法栈（Native Method Stacks）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Java堆（Java-Heap）"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 Java堆（Java Heap）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-方法区（Method-Area）"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 方法区（Method Area）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Java内存模型"><span class="nav-number">3.</span> <span class="nav-text">3. Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-主内存和工作内存"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 主内存和工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-内存间交互操作"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-重排序和内存屏障"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 重排序和内存屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-内存可见性"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 内存可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-volatile实现的可见性"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 volatile实现的可见性</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lizhiyong</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">43.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
