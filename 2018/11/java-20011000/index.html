<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="AbstractQueuedSynchronizer," />










<meta name="description" content="在看AbstractQueuedSynchronizer源码之前，首先需要弄明白的是AbstractQueuedSynchronizer有什么用，我们知道多个线程修改同一个共享变量，可能会出现各种我们不希望的结果，通常要想保证同一个共享变量在多线程下的安全，需要用到锁，而java程序是运行在虚拟机上的，无法直接调用内存中的变量，也无法使用操作系统的中的锁。那么java中的锁是怎么实现的呢？答案就是">
<meta name="keywords" content="AbstractQueuedSynchronizer">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发-AbstractQueuedSynchronizer源码解析">
<meta property="og:url" content="https://lizy-tech.github.io/2018/11/java-20011000/index.html">
<meta property="og:site_name" content="lizy-tech">
<meta property="og:description" content="在看AbstractQueuedSynchronizer源码之前，首先需要弄明白的是AbstractQueuedSynchronizer有什么用，我们知道多个线程修改同一个共享变量，可能会出现各种我们不希望的结果，通常要想保证同一个共享变量在多线程下的安全，需要用到锁，而java程序是运行在虚拟机上的，无法直接调用内存中的变量，也无法使用操作系统的中的锁。那么java中的锁是怎么实现的呢？答案就是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lizy-tech.github.io/2018/11/java-20011000/aqs.jpg">
<meta property="og:updated_time" content="2018-12-03T12:50:03.260Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发-AbstractQueuedSynchronizer源码解析">
<meta name="twitter:description" content="在看AbstractQueuedSynchronizer源码之前，首先需要弄明白的是AbstractQueuedSynchronizer有什么用，我们知道多个线程修改同一个共享变量，可能会出现各种我们不希望的结果，通常要想保证同一个共享变量在多线程下的安全，需要用到锁，而java程序是运行在虚拟机上的，无法直接调用内存中的变量，也无法使用操作系统的中的锁。那么java中的锁是怎么实现的呢？答案就是">
<meta name="twitter:image" content="https://lizy-tech.github.io/2018/11/java-20011000/aqs.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lizy-tech.github.io/2018/11/java-20011000/"/>





  <title>java并发-AbstractQueuedSynchronizer源码解析 | lizy-tech</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lizy-tech</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">编程的苦与乐</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lizy-tech.github.io/2018/11/java-20011000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lizhiyong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lizy-tech">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java并发-AbstractQueuedSynchronizer源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T20:06:06+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,402 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在看AbstractQueuedSynchronizer源码之前，首先需要弄明白的是AbstractQueuedSynchronizer有什么用，我们知道多个线程修改同一个共享变量，可能会出现各种我们不希望的结果，通常要想保证同一个共享变量在多线程下的安全，需要用到锁，而java程序是运行在虚拟机上的，无法直接调用内存中的变量，也无法使用操作系统的中的锁。那么java中的锁是怎么实现的呢？<br>答案就是AbstractQueuedSynchronizer——同步队列（以下简称AQS），在AQS中维护一个队列，队列中的结点存储的线程，通过一些变量值的改变来改变对应线程的运行状态，从可以实现锁的功能。<br>AbstractQueuedSynchronizer提供了一种框架，用于实现阻塞锁和其他基于先入先出（FIFO）等待队列的同步组件。该类用一个Int类型的原子变量来表示一种状态。子类必须实现该类的protect方法，以此来改变同步状态。在获取或释放该状态时，需要定义这个状态值。类中的其他方法实现了线程入队与阻塞功能，子类依然可以维护其他状态字段，但是只能使用getState、setState、compareAndSetState方法来跟踪同步状态。<br>子类应该定义为非公共的内部工具类，并需要在类中实现相应的同步方法。支持独占式与共享式的获取同步状态。如果是独占模式，那么其他线程则不能获取到，而共享式则允许多个线程同时获取。两种不同模式下的等待线程共享同一个队列，通常实现的子类只支持一种模式，但是也有两种都支持的，如ReadWriteLock。仅支持独占或共享的子类可以不用实现对应模式所定义的方法。<br>AbstractQueuedSynchronizer类中定义了一个嵌套类ConditionObject。ConditionObject主要提供一种条件，由子类决定是否支持独占模式，并由isHeldExclusively方法决定当前线程是否是独占的获取同步状态。<br>下面具体来说说AQS：</p>
<h1 id="一、AQS源码"><a href="#一、AQS源码" class="headerlink" title="一、AQS源码"></a>一、AQS源码</h1><h2 id="1-1-类的继承"><a href="#1-1-类的继承" class="headerlink" title="1.1 类的继承"></a>1.1 类的继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>从类的继承上可以看出AQS继承了AbstractOwnableSynchronizer抽象类，并且实现Serializable接口。AbstractOwnableSynchronizer抽象类的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    //版本序列号</span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    //独占模式下的线程</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-AQS的内部类"><a href="#1-2-AQS的内部类" class="headerlink" title="1.2 AQS的内部类"></a>1.2 AQS的内部类</h2><p>AQS有两个内部类，分别是Node类和ConditionObject类，下面分别介绍：</p>
<h3 id="1-2-1-Node类"><a href="#1-2-1-Node类" class="headerlink" title="1.2.1 Node类"></a>1.2.1 Node类</h3><p>Node为等待队列节点，等待队列是一种“CLH(自旋锁)”锁队列。我们用自旋锁来实现阻塞同步器，但用的是同样的策略来控制一个线程的前驱节点的信息。每个节点中的status字段记录了一个线程是否已阻塞。当一个节点的前驱节点释放锁后会以信号的形式通知该节点，队列的每个结点作为一个特定通知风格（specific-notification-style）的监视器服务，会持有一个单独的等待线程，但是status字段不会控制是否线程能被赋予锁。如果一个线程是第一个进入队列的节点，他就可以尝试获取锁，但是也不能保证获取成功，只是有了竞争的权利。所以当前释放锁的竞争者线程可能需要再次等待。<br>为了进入CLH锁队列，你只需要原子的拼接成一个尾节点。要出队列的话，你仅需要设置head字段即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    //模式，分为共享和独占；SHARED标识共享模式</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    //独占模式</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    //等待状态值，表示当前线程被取消</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    //等待状态值，表示当前结点的后继结点包含的线程需要运行（被唤醒），也就是unpark</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    //等待状态值，表示当前节点在等待condition，也就是在condition队列中</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    /**</span><br><span class="line">     * waitStatus value to indicate the next acquireShared should</span><br><span class="line">     * unconditionally propagate</span><br><span class="line">     */等待状态值，表示当前场景下后续的acquireShared能够得以执行</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">	 * 状态字段，取值如下：</span><br><span class="line">	 * SIGNAL: 当前结点的后继节点将会是阻塞的（通过park方法），因此当前结点需要唤醒他的后继节点，当他释放或取消后。为了避免竞争，</span><br><span class="line">	 *      获取同步状态的方法必须抢先表示自己需要信号，然后重新原子的获取。最后可能是获取失败，或者再次被阻塞。</span><br><span class="line">	 * CANCELLED：  由于超时、中断等原因，当前结点会被取消。取消后，节点不会释放状态。特殊情景下，被取消的节点中的线程将不会再被阻塞</span><br><span class="line">	 * CONDITION：  当前结点在一个条件队列中，再被转移之前将不会被作为同步节点。被转移时该值会被设置为0。</span><br><span class="line">	 * PROPAGATE：  共享式方式释放同步状态后应该被传播到其他节点。这种设置（仅对head节点）在doReleaseShared方法中确保了可以持续，及时有其他的干预操作。</span><br><span class="line">	 * 0：  非以上状</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    //结点状态 通常sync结点初始值为0，condition结点初始值为CONDITION</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指向当前节点的上一个节点，当前节点依赖它来检测waitStatus</span><br><span class="line">	 * 在当前节点进入等待队列时赋值，在移除队列时置空，或者当前节点线程被取消时置空</span><br><span class="line">     */</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    //当前结点（线程）在释放同步状态后会唤醒的后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    //节点关联的线程，构造时被初始化、用完后置空</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      链向的下一个等待节点，或是一个特殊值SHARED.由于只能是独占式的访问条件队列，</span><br><span class="line">      所以只需简单的链向队列就行了。又由于条件只能是独占式的获取，我们保留了一个字段并使用特殊的值来表示共享模式。</span><br><span class="line">     */</span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    //如果节点是以共享模式在等待，则返回true</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回前驱结点</span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    // Used to establish initial head or SHARED marker</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-ConditionObject类"><a href="#1-2-2-ConditionObject类" class="headerlink" title="1.2.2 ConditionObject类"></a>1.2.2 ConditionObject类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ConditionObject的实现,其实其维护两个队列</span><br><span class="line"> * 1)Condition队列,表示等待的队列,其waitStatus=Node.CONDITION,由firstWaiter和lastWaiter两个属性操控. </span><br><span class="line"> * 2)Sync队列,表示可以竞争锁的队列,这个跟AQS一致,waitStatus=0;</span><br><span class="line"> * 3)await()把当前线程创建一个Node加入Condition队列,接着就一直循环查其在不在Sync队列</span><br><span class="line"> *   如果当前节点在Sync队列里了,就可以竞争锁,恢复运行了.</span><br><span class="line"> * 4)signal()方法就是把某个节点的nextWaiter设为null,再把其从Condition队列转到Sync队列</span><br><span class="line"> */</span><br><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1173984872572414699L;</span><br><span class="line">    //condition队列的头结点和尾结点</span><br><span class="line">    private transient Node firstWaiter;</span><br><span class="line">    private transient Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    public ConditionObject() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // Internal methods</span><br><span class="line"></span><br><span class="line">    //添加新的waiter到wait队列</span><br><span class="line">    private Node addConditionWaiter() &#123;</span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">        // If lastWaiter is cancelled, clean out.</span><br><span class="line">        if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();//遍历condition队列，移除其中非CONDITION状态的元素</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        //新建一个CONDITION状态的节点,并将其加在condition队列尾部</span><br><span class="line">        Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        if (t == null)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        else</span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    private void doSignal(Node first) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            if ( (firstWaiter = first.nextWaiter) == null)//第一个元素空了，说明condition队列空了</span><br><span class="line">                lastWaiter = null;</span><br><span class="line">            first.nextWaiter = null;</span><br><span class="line">        //如果转换队列不成功且condition队列不为null,继续循环</span><br><span class="line">        &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //唤醒所有等待在此condition的所有线程</span><br><span class="line">    private void doSignalAll(Node first) &#123;</span><br><span class="line">        lastWaiter = firstWaiter = null;</span><br><span class="line">        do &#123;</span><br><span class="line">            Node next = first.nextWaiter;</span><br><span class="line">            first.nextWaiter = null;</span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; while (first != null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历condition队列，移除其中非CONDITION状态的元素,（单链表删除指定值的元素）</span><br><span class="line">    private void unlinkCancelledWaiters() &#123;</span><br><span class="line">        Node t = firstWaiter;</span><br><span class="line">        Node trail = null;</span><br><span class="line">        while (t != null) &#123;</span><br><span class="line">            Node next = t.nextWaiter;</span><br><span class="line">            if (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                t.nextWaiter = null;//t就从condition中移除了</span><br><span class="line">                if (trail == null)</span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                else</span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                if (next == null)</span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                trail = t;</span><br><span class="line">            t = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // public methods</span><br><span class="line"></span><br><span class="line">    //将等待时间最长的线程(如果存在的话)从该条件的等待队列移动到拥有锁的等待队列。</span><br><span class="line">    public final void signal() &#123;</span><br><span class="line">        if (!isHeldExclusively())//非独占模式，抛出异常</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        if (first != null)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //唤醒所有等待在此condition的所有线程</span><br><span class="line">    public final void signalAll() &#123;</span><br><span class="line">        if (!isHeldExclusively())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">        if (first != null)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 暂停此线程,直至进入SyncQueue</span><br><span class="line">     * 线程唤醒时如果还是不在SyncQueue，会继续park</span><br><span class="line">     */</span><br><span class="line">    public final void awaitUninterruptibly() &#123;</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        int savedState = fullyRelease(node);</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Mode meaning to reinterrupt on exit from wait */</span><br><span class="line">    private static final int REINTERRUPT =  1;</span><br><span class="line">    /** Mode meaning to throw InterruptedException on exit from wait */</span><br><span class="line">    private static final int THROW_IE    = -1;</span><br><span class="line"></span><br><span class="line">    private int checkInterruptWhileWaiting(Node node) &#123;</span><br><span class="line">        return Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">            0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Throws InterruptedException, reinterrupts current thread, or</span><br><span class="line">     * does nothing, depending on mode.</span><br><span class="line">     */</span><br><span class="line">    private void reportInterruptAfterWait(int interruptMode)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (interruptMode == THROW_IE)</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        else if (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void await() throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        int savedState = fullyRelease(node);</span><br><span class="line">        int interruptMode = 0;</span><br><span class="line">        while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        if (interruptMode != 0)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final long awaitNanos(long nanosTimeout)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        int savedState = fullyRelease(node);</span><br><span class="line">        final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        int interruptMode = 0;</span><br><span class="line">        while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            if (nanosTimeout &lt;= 0L) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                break;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        if (node.nextWaiter != null)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        if (interruptMode != 0)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        return deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean awaitUntil(Date deadline)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        long abstime = deadline.getTime();</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        int savedState = fullyRelease(node);</span><br><span class="line">        boolean timedout = false;</span><br><span class="line">        int interruptMode = 0;</span><br><span class="line">        while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            if (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkUntil(this, abstime);</span><br><span class="line">            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        if (node.nextWaiter != null)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        if (interruptMode != 0)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        return !timedout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean await(long time, TimeUnit unit)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        long nanosTimeout = unit.toNanos(time);</span><br><span class="line">        if (Thread.interrupted())</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        int savedState = fullyRelease(node);</span><br><span class="line">        final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        boolean timedout = false;</span><br><span class="line">        int interruptMode = 0;</span><br><span class="line">        while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            if (nanosTimeout &lt;= 0L) &#123;</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                break;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        if (node.nextWaiter != null)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        if (interruptMode != 0)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        return !timedout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean isOwnedBy(AbstractQueuedSynchronizer sync) &#123;</span><br><span class="line">        return sync == AbstractQueuedSynchronizer.this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean hasWaiters() &#123;</span><br><span class="line">        if (!isHeldExclusively())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123;</span><br><span class="line">            if (w.waitStatus == Node.CONDITION)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final int getWaitQueueLength() &#123;</span><br><span class="line">        if (!isHeldExclusively())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        int n = 0;</span><br><span class="line">        for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123;</span><br><span class="line">            if (w.waitStatus == Node.CONDITION)</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取condition队列中所有等待的线程并返回</span><br><span class="line">    protected final Collection&lt;Thread&gt; getWaitingThreads() &#123;</span><br><span class="line">        if (!isHeldExclusively())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();</span><br><span class="line">        for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123;</span><br><span class="line">            if (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                if (t != null)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConditionObject类实现了Condition接口，Condition接口定义了条件操作规范，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line"></span><br><span class="line">    //等待，当前线程在接到信号或被中断之前一直处于等待状态</span><br><span class="line">    void await() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    //等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span><br><span class="line">    void awaitUninterruptibly();</span><br><span class="line"></span><br><span class="line">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    //唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁</span><br><span class="line">    void signal();</span><br><span class="line"></span><br><span class="line">    void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-类的属性"><a href="#1-3-类的属性" class="headerlink" title="1.3 类的属性"></a>1.3 类的属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 7373984972572414691L;</span><br><span class="line">    private transient volatile Node head;</span><br><span class="line">    private transient volatile Node tail;</span><br><span class="line">    private volatile int state;</span><br><span class="line"></span><br><span class="line">    static final long spinForTimeoutThreshold = 1000L;//自旋时间</span><br><span class="line"></span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long stateOffset;</span><br><span class="line">    private static final long headOffset;</span><br><span class="line">    private static final long tailOffset;</span><br><span class="line">    private static final long waitStatusOffset;</span><br><span class="line">    private static final long nextOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-核心函数"><a href="#1-4-核心函数" class="headerlink" title="1.4 核心函数"></a>1.4 核心函数</h2><h3 id="1-4-1-acquire函数"><a href="#1-4-1-acquire函数" class="headerlink" title="1.4.1 acquire函数"></a>1.4.1 acquire函数</h3><p>该函数以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先调用tryAcquire函数，调用此方法的线程会试图在独占模式下获取对象状态。需要子类去重写此函数完成自己的逻辑</li>
<li>若tryAcquire失败，则调用addWaiter函数，addWaiter函数完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。</li>
<li>调用acquireQueued函数，此函数完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);新生成一个结点</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//addWaiter函数使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下　</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;//入队</span><br><span class="line">    for (;;) &#123;//无限循环  保证结点入队成功</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在分析acquireQueued()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// sync队列中的结点在独占且忽略中断的模式下获取(资源)</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();// 获取node节点的前驱结点</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先获取当前节点的前驱节点，如果前驱节点是头结点并且能够获取(资源)，代表该当前节点能够占有锁，设置头结点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt函数，首先，我们看shouldParkAfterFailedAcquire函数，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//当获取(资源)失败后，检查并且更新结点状态</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    if (ws == Node.SIGNAL)//状态为SIGNAL，为-1   可以进行park操作</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;//表示状态为CANCELLED，为1</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span><br><span class="line">        pred.next = node;// 赋值pred结点的next域</span><br><span class="line">    &#125; else &#123;// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);// 比较并设置前驱结点的状态为SIGNAL</span><br><span class="line">    &#125;</span><br><span class="line">    return false;// 不能进行park操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt函数，源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//进行park操作并且返回该线程是否被中断</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);//在许可可用之前禁用当前线程，并且设置了blocker</span><br><span class="line">    return Thread.interrupted();//当前线程是否已被中断，并清除中断标记位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parkAndCheckInterrupt函数里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelAcquire函数，其源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">    // node为空，返回</span><br><span class="line">    if (node == null)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    node.thread = null;</span><br><span class="line"></span><br><span class="line">    Node pred = node.prev; // 保存node的前驱结点</span><br><span class="line">    while (pred.waitStatus &gt; 0)// 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    // 获取pred结点的下一个结点</span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    // 设置node结点的状态为CANCELLED</span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;// node结点为尾结点，则设置尾结点为pred结点</span><br><span class="line">        compareAndSetNext(pred, predNext, null);// 比较并设置pred结点的next节点为null</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int ws;</span><br><span class="line">        // （pred结点不为头结点，并且pred结点的状态为SIGNAL）或者 </span><br><span class="line">        // pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空</span><br><span class="line">        if (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != null) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            if (next != null &amp;&amp; next.waitStatus &lt;= 0)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            unparkSuccessor(node); // 释放node的前一个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; // help GC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着我们再看unparkSuccessor函数，源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    // 获取node结点的等待状态</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span><br><span class="line">     	// 比较并且设置结点等待状态，设置为0</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span><br><span class="line">        s = null;</span><br><span class="line">        //从尾结点开始从后往前开始遍历</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)// 该结点不为为空，释放许可</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数的作用就是为了释放node节点的后继结点。</p>
<p>现在，再来看acquireQueued函数的整个的逻辑。逻辑如下</p>
<ol>
<li><p>判断结点的前驱是否为head并且是否成功获取(资源)。</p>
</li>
<li><p>若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。</p>
</li>
<li><p>若步骤1不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。</p>
</li>
<li><p>若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤1的判断。</p>
</li>
</ol>
<h3 id="1-4-2-release函数"><a href="#1-4-2-release函数" class="headerlink" title="1.4.2 release函数"></a>1.4.2 release函数</h3><p>以独占模式释放对象，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;// // 释放成功</span><br><span class="line">        Node h = head; // 保存头结点</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)// 头结点不为空并且头结点状态不为0</span><br><span class="line">            unparkSuccessor(h);//释放头结点的后继结点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头结点不为空并且头结点的状态不为0，则释放头结点的后继结点，unparkSuccessor函数已经分析过，不再累赘。</p>
<p>对于其他函数我们也可以分析，与前面分析的函数大同小异，所以，不再累赘。</p>
<h1 id="二、AQS的数据结构"><a href="#二、AQS的数据结构" class="headerlink" title="二、AQS的数据结构"></a>二、AQS的数据结构</h1><p>AQS的数据结构如下：<br><img src="/2018/11/java-20011000/aqs.jpg" title="图1 AQS的数据结构"><br>AQS类底层的数据结构是使用双向链表，是队列的一种实现，故也可看成是队列，其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/AbstractQueuedSynchronizer/" rel="tag"># AbstractQueuedSynchronizer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/java-20001000/" rel="next" title="java并发-locks包小结">
                <i class="fa fa-chevron-left"></i> java并发-locks包小结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lizhiyong</p>
              <p class="site-description motion-element" itemprop="description">菜鸟的涅槃梦</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、AQS源码"><span class="nav-number">1.</span> <span class="nav-text">一、AQS源码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-类的继承"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-AQS的内部类"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 AQS的内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-Node类"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 Node类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-ConditionObject类"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 ConditionObject类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-类的属性"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 类的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-核心函数"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 核心函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-acquire函数"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 acquire函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-release函数"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2 release函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、AQS的数据结构"><span class="nav-number">2.</span> <span class="nav-text">二、AQS的数据结构</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lizhiyong</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">43.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
